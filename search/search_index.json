{
    "docs": [
        {
            "location": "/",
            "text": "Getting started\n\n\nIf you'd like, there is a video here[INSERT LINK] covering everthing in this page.\n\n\nThe input manager asset file\n\n\nThe first thing you want to do when you import EzInput to your project is substitute the \nInputManager.asset\n file in your project's \nProjectSettings\n folder with the file in \nInputManager.zip\n, that came with the EzInput. The reason for this is that EzInput uses Unity's built-in input manager but there is no way of accessing specific axes of specific controllers manually by code so we need to create roughly 250 (yeah...) entries in the input manager to be able to read those values. If you didn't get it, nervermind, just do it \ud83d\ude42.\n\n\n\n\nWarning\n\n\nyou might want to make a backup of your \nInputManager.asset\n since you might want that input configuration back in case you decide not to use EzInput (not that there is a reason for taking a stupid decision as that \ud83d\ude05).\n\n\n\n\nSetting up the bindings\n\n\nIf you go to \nEzInput/Data\n you'll see there are a few Scriptable Objects there, you'll be modifying those (and creating more if needed) to fit your needs. The \nEzInputBindings\n file is where all your bindings will be stored. If you click on the \nEzInputBindings\n file and then \"Add\" in it's editor a new binding will show up in the list. You can change the input type of the binding to be either a Button or an Axis and configure it to your needs. You can read an in-depth review on the Bindings file \nhere\n.\n\n\nReading the values through code\n\n\nThe best way to explain how to read values is by using examples, so here they are:\n\n\n//This will return true when the user presses the Cross button on a PS4 controller or A button on an XBox controller in any of the connected controllers\n\n\nEzInput\n.\nGetButton\n(\nButtonCode\n.\nCross_A\n,\n \nInputType\n.\nPress\n,\n \nEzInput\n.\nALL\n);\n\n\n\n//This will return true if the left d-pad button is pressed down on the third controller (controller IDs are zero-based)\n\n\nEzInput\n.\nGetButton\n(\n\"Jump\"\n,\n \nInputType\n.\nHold\n,\n \n2\n);\n\n\n\n//This will return true when the \"Jump\" button binding is released on all controllers. Controller ID default to EzInput.All\n\n\nEzInput\n.\nGetButton\n(\n\"Jump\"\n,\n \nInputType\n.\nRelease\n);\n\n\n\n//This will return a float value for the axis binding \"Horizontal Movement\". Again, Controller ID defaults to EzInput.All\n\n\nEzInput\n.\nGetAxis\n(\n\"Horizontal Movement\"\n);\n\n\n\n//This will return a float value for the axis binding \"Vertical Movement\" on the second controller.\n\n\nEzInput\n.\nGetAxis\n(\n\"Vertical Movement\"\n,\n \n1\n);\n\n\n\n//This will return a float value for the left stick X axis on all controllers.\n\n\nEzInput\n.\nGetAxis\n(\nAxisCode\n.\nLeftStick_X\n,\n \nEzInput\n.\nALL\n);\n\n\n\n\n\n\nHere's a table explaining the \nInputType\n enum:\n\n\n\n\n\n\n\n\nInputType\n\n\nUnity equivalent\n\n\n\n\n\n\n\n\n\n\nInputType.Hold\n\n\nInput.GetButton()\n\n\n\n\n\n\nInputType.Press\n\n\nInput.GetButtonDown()\n\n\n\n\n\n\nInputType.Release\n\n\nInput.GetButtonUp()\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nRegarding the controller ID parameter in \nGetButton\n and \nGetAxis\n:\n\n1. It is relative to \nInput.GetJoystickNames()\n\n2. It is an optional parameter and will default to \nEzInput.ALL\n (getting input from all controllers)\n\n3. it is zero-based  \n\n\n\n\n\n\nNote\n\n\nWhen reading the input from all controllers (using \nEzInput.ALL\n):\n\n- In the case of a \nGetButton()\n call the value returned will be true if the button is pressed in any controller\n\n- In the case of a \nGetAxis()\n call the value returned will be the sum of the value of the axis on all controllers clamped between -1 and 1. For example: if there are three controllers with the axis at -1 then -1 * 3 = -3, clamp that between -1 and 1, the value returned will be -1.",
            "title": "Getting started"
        },
        {
            "location": "/#getting-started",
            "text": "If you'd like, there is a video here[INSERT LINK] covering everthing in this page.",
            "title": "Getting started"
        },
        {
            "location": "/#the-input-manager-asset-file",
            "text": "The first thing you want to do when you import EzInput to your project is substitute the  InputManager.asset  file in your project's  ProjectSettings  folder with the file in  InputManager.zip , that came with the EzInput. The reason for this is that EzInput uses Unity's built-in input manager but there is no way of accessing specific axes of specific controllers manually by code so we need to create roughly 250 (yeah...) entries in the input manager to be able to read those values. If you didn't get it, nervermind, just do it \ud83d\ude42.   Warning  you might want to make a backup of your  InputManager.asset  since you might want that input configuration back in case you decide not to use EzInput (not that there is a reason for taking a stupid decision as that \ud83d\ude05).",
            "title": "The input manager asset file"
        },
        {
            "location": "/#setting-up-the-bindings",
            "text": "If you go to  EzInput/Data  you'll see there are a few Scriptable Objects there, you'll be modifying those (and creating more if needed) to fit your needs. The  EzInputBindings  file is where all your bindings will be stored. If you click on the  EzInputBindings  file and then \"Add\" in it's editor a new binding will show up in the list. You can change the input type of the binding to be either a Button or an Axis and configure it to your needs. You can read an in-depth review on the Bindings file  here .",
            "title": "Setting up the bindings"
        },
        {
            "location": "/#reading-the-values-through-code",
            "text": "The best way to explain how to read values is by using examples, so here they are:  //This will return true when the user presses the Cross button on a PS4 controller or A button on an XBox controller in any of the connected controllers  EzInput . GetButton ( ButtonCode . Cross_A ,   InputType . Press ,   EzInput . ALL );  //This will return true if the left d-pad button is pressed down on the third controller (controller IDs are zero-based)  EzInput . GetButton ( \"Jump\" ,   InputType . Hold ,   2 );  //This will return true when the \"Jump\" button binding is released on all controllers. Controller ID default to EzInput.All  EzInput . GetButton ( \"Jump\" ,   InputType . Release );  //This will return a float value for the axis binding \"Horizontal Movement\". Again, Controller ID defaults to EzInput.All  EzInput . GetAxis ( \"Horizontal Movement\" );  //This will return a float value for the axis binding \"Vertical Movement\" on the second controller.  EzInput . GetAxis ( \"Vertical Movement\" ,   1 );  //This will return a float value for the left stick X axis on all controllers.  EzInput . GetAxis ( AxisCode . LeftStick_X ,   EzInput . ALL );   Here's a table explaining the  InputType  enum:     InputType  Unity equivalent      InputType.Hold  Input.GetButton()    InputType.Press  Input.GetButtonDown()    InputType.Release  Input.GetButtonUp()      Note  Regarding the controller ID parameter in  GetButton  and  GetAxis : \n1. It is relative to  Input.GetJoystickNames() \n2. It is an optional parameter and will default to  EzInput.ALL  (getting input from all controllers) \n3. it is zero-based      Note  When reading the input from all controllers (using  EzInput.ALL ): \n- In the case of a  GetButton()  call the value returned will be true if the button is pressed in any controller \n- In the case of a  GetAxis()  call the value returned will be the sum of the value of the axis on all controllers clamped between -1 and 1. For example: if there are three controllers with the axis at -1 then -1 * 3 = -3, clamp that between -1 and 1, the value returned will be -1.",
            "title": "Reading the values through code"
        },
        {
            "location": "/bindings/",
            "text": "The bindings\n\n\nIf you go to \nEzInput/Data\n you'll see there are a few Scriptable Objects there, you'll be modifying those (and creating more if needed) to fit your needs. The \nEzInputBindings\n file is where all your bindings will be stored. If you click on the \nEzInputBindings\n file and then \"Add\" in it's editor a new binding will show up in the list. You can change the input type of the binding to be either a Button or an Axis and configure it to your needs.\n\n\n\n\nNote\n\n\nYou can create a new bindings file through the Create menu.\n\n\n\n\nButton bindings\n\n\nIf you set the binding type to button you just need to select a button from the dropdown for your binding. The buttons available in the dropdown have names for the same positions in a PS4 controller or an XBox controller (Cross in a PS4 controller is equivalent to A in an XBox controller). \"But what if I want a keyboard key?\" you ask, the answer is simple: if you check \"Key as button\" you will be able to select a key from the dropdown. You're done, your button binding is set up.\n\nThere's also another possibility: turning an axis to a button. To do that check \"Axis as button\", select the axis you want in the dropdown and configure the \"Released zone\". The released zone determines when the button is at the released state, so if the modulus of the axis value (the square root of the axis value\u00b2, making negative values positive) is smaller that the released zone the button will be in the released state,if greater then the button will be in the pressed state. If you want the \"Released zone\" to turn into a \"Pressed zone\" check \"Invert?\", it will work in \"reverse\" so when the modulus of the axis value is smaller than the \"pressed zone\" the button will be in the pressed state.\n\n\nAxis bindings\n\n\nIf the binding type of your binding is set to Axis there are a few options you can change. First, you can select an axis for your binding from the dropdown, then you can set a deadzone to it and invert it if you'd like.\n\n\n\n\nNote\n\n\nThe deadzone set in the bindings will be added to the deadzone set in the InputConfigs. Example: if the LeftStick_X axis has a 0.19 deadzone in the InputConfigs and your binding has a 0.1 deadzone then the actual deadzone of the LeftStick_X axis will be 0.29.\n\n\n\n\nYou can also make a button behave as an axis (i.e. when the button is pressed the axis binding value will be 1 and when the button is released the binding value will be 0). To do that just check \"Button as axis\", select a button and set the pressed and released values. If you want to make a key behave as an axis just check \"Key as axis\".\n\n\nMultiple bindings with the same name\n\n\nIf you want two buttons to do the same thing in your game you can have multiple bindings with the same name. When you call \nGetButton(\"Jump\", InputType.Hold)\n true will",
            "title": "Bindings"
        },
        {
            "location": "/bindings/#the-bindings",
            "text": "If you go to  EzInput/Data  you'll see there are a few Scriptable Objects there, you'll be modifying those (and creating more if needed) to fit your needs. The  EzInputBindings  file is where all your bindings will be stored. If you click on the  EzInputBindings  file and then \"Add\" in it's editor a new binding will show up in the list. You can change the input type of the binding to be either a Button or an Axis and configure it to your needs.   Note  You can create a new bindings file through the Create menu.",
            "title": "The bindings"
        },
        {
            "location": "/bindings/#button-bindings",
            "text": "If you set the binding type to button you just need to select a button from the dropdown for your binding. The buttons available in the dropdown have names for the same positions in a PS4 controller or an XBox controller (Cross in a PS4 controller is equivalent to A in an XBox controller). \"But what if I want a keyboard key?\" you ask, the answer is simple: if you check \"Key as button\" you will be able to select a key from the dropdown. You're done, your button binding is set up. \nThere's also another possibility: turning an axis to a button. To do that check \"Axis as button\", select the axis you want in the dropdown and configure the \"Released zone\". The released zone determines when the button is at the released state, so if the modulus of the axis value (the square root of the axis value\u00b2, making negative values positive) is smaller that the released zone the button will be in the released state,if greater then the button will be in the pressed state. If you want the \"Released zone\" to turn into a \"Pressed zone\" check \"Invert?\", it will work in \"reverse\" so when the modulus of the axis value is smaller than the \"pressed zone\" the button will be in the pressed state.",
            "title": "Button bindings"
        },
        {
            "location": "/bindings/#axis-bindings",
            "text": "If the binding type of your binding is set to Axis there are a few options you can change. First, you can select an axis for your binding from the dropdown, then you can set a deadzone to it and invert it if you'd like.   Note  The deadzone set in the bindings will be added to the deadzone set in the InputConfigs. Example: if the LeftStick_X axis has a 0.19 deadzone in the InputConfigs and your binding has a 0.1 deadzone then the actual deadzone of the LeftStick_X axis will be 0.29.   You can also make a button behave as an axis (i.e. when the button is pressed the axis binding value will be 1 and when the button is released the binding value will be 0). To do that just check \"Button as axis\", select a button and set the pressed and released values. If you want to make a key behave as an axis just check \"Key as axis\".",
            "title": "Axis bindings"
        },
        {
            "location": "/bindings/#multiple-bindings-with-the-same-name",
            "text": "If you want two buttons to do the same thing in your game you can have multiple bindings with the same name. When you call  GetButton(\"Jump\", InputType.Hold)  true will",
            "title": "Multiple bindings with the same name"
        },
        {
            "location": "/controller-profiles/",
            "text": "Controller Profiles\n\n\nIf you go to \nEzInput/Data\n you will see that there are a few controller profile Scriptable Objects. Each of those files stores the button IDs for every button and axis of the controller. Since EzInput is based on Unity's native Input system EzInput needs this to get the correct button from the controller.\n\nIf you open Edit->Project Settings->Input in the Editor and open a binding there you can see that there is an \"Axis\" dropdown with X, Y, 3rd Axis, 4th Axis, 5th Axis and so on. This is the ID of the axis (X is 1 and Y is 2). How about buttons? To get a joystick button in Unity's Input Manager you have to set \"Positive button\" to \"joystick button 0\" (where 0 is the ID of the button).\n\nSo, basically, \nControllerProfile\n files map those IDs to easily readable names (instead of configuring a binding to button 1 you configure it to Cross_A). Another positive side of this \"mapping\" is that you are able to set up many controllers in many platforms easily and separate the bindings themselves from the button and axis IDs.\n\n\n\n\nNote\n\n\nThe \"Name\" field is used by EzInput to find the correct \nInputConfigs\n file for the connected controller so that name has to be \nexactly\n the same as the controller name (you can find the controller name using \nInput.GetControllerNames()\n).\n\n\n\n\nAs you can see, configuring buttons are no mystery but configuring the axes and the D-Pad can get a bit complicated.\n\n\nThe D-Pad\n\n\nD-Pads can be treated in two ways depending on the controller and the platform: they can be buttons (each DPad button has a button ID) or axes (one horizontal axis and one vertical axis). On Windows the XBox360 controller D-Pad is treated as a pair of axes (the horizontal and the vertical), so because of that we need to check \"DPad is axis\" and edit DPad horizontal and DPad vertical accordingly. If, for instance, your controller treats the D-Pad as buttons, uncheck \"DPad is axis\" and configure the button IDs in the Buttons section.\n\n\nThe Axes\n\n\nEach axis has an ID, an input range, an output range and can be inverted. The ID and inversion of the value is pretty straight forward, but what are these input and output ranges? The input range is the value EzInput will receive from the controller and the output range is what you will get when you call \nGetAxis()\n. For example: in the PS4 controller on PC trigger values range from -1 to 1 (-1 being fully released and 1 being fully pressed) but it seems more logical to have it ranging between 0 and 1, don't you think? So we have to set \"Min input range\" to -1, \"Max input range\" to 1, \"Min output range\" to 0 and \"Max output range\" to 1.\n\n\nCreating a controller profile\n\n\nTo create a new controller profile file go to the Project tab in the Editor, right click, Create->EzInput->Controller Profile. \n\n\nSetting the name of the controller\n\n\nThe profile stores the name of the controller it is for in the \"Name\" field (it's the first field in the controller profile editor, you'll find it). Be careful when setting the controller name because it has to match exactly the name of the controller. You can find the name of your controller in the \ntest scene\n or you can use \nInput.GetJoystickNames()\n and look into the string array it returns.\n\n\nSetting the platform of the profile\n\n\nYou can restrict a controller profile to a specific platform by selecting it in the \"Target platform\" field (you can also select multiple target platforms). Now, you'd probably be asking yourself why do this? The reason behind that is simple. Let's take the XBox 360 controller, in Windows the D-pad works as a pair of axes but in OSX the D-pad is treated as group of buttons. So if you had the same profile for Windows and OSX you'd get incorrect input from the same controller.\n\n\n\n\nNote\n\n\nIf the platform you're selecting is WindowsPlayer, OSXPlayer or LinuxPlayer dont forget to check their editor versions (WindowsEditor, OSXEditor, LinuxEditor). If you dont do this your controller profile won't work in the editor (but it will work on a build).\n\n\n\n\nYou'll also need to add it to the list in the EzInput prefab located at \nEzInput/Resources\n, if you don't EzInput won't even know it exists.\n\n\n\n\nWarning\n\n\nDon't forget to add your new Controller Config file to the list in the EzInput prefab in \nEzInput/Resources\n. I know it's written on the line above but you might have skipped that part so here's a big orange warning to catch your attention and save you a headache. You're welcome :)\n\n\n\n\nDefault Controller Profile\n\n\nWhen you connect a controller EzInput tries to find a ControllerProfile that matches your controller and platform. If it can't find one it uses the default controller profile. The default controller profile is located at the EzInput prefab in \nEzInput/Resources\n.",
            "title": "Controller profiles"
        },
        {
            "location": "/controller-profiles/#controller-profiles",
            "text": "If you go to  EzInput/Data  you will see that there are a few controller profile Scriptable Objects. Each of those files stores the button IDs for every button and axis of the controller. Since EzInput is based on Unity's native Input system EzInput needs this to get the correct button from the controller. \nIf you open Edit->Project Settings->Input in the Editor and open a binding there you can see that there is an \"Axis\" dropdown with X, Y, 3rd Axis, 4th Axis, 5th Axis and so on. This is the ID of the axis (X is 1 and Y is 2). How about buttons? To get a joystick button in Unity's Input Manager you have to set \"Positive button\" to \"joystick button 0\" (where 0 is the ID of the button). \nSo, basically,  ControllerProfile  files map those IDs to easily readable names (instead of configuring a binding to button 1 you configure it to Cross_A). Another positive side of this \"mapping\" is that you are able to set up many controllers in many platforms easily and separate the bindings themselves from the button and axis IDs.   Note  The \"Name\" field is used by EzInput to find the correct  InputConfigs  file for the connected controller so that name has to be  exactly  the same as the controller name (you can find the controller name using  Input.GetControllerNames() ).   As you can see, configuring buttons are no mystery but configuring the axes and the D-Pad can get a bit complicated.",
            "title": "Controller Profiles"
        },
        {
            "location": "/controller-profiles/#the-d-pad",
            "text": "D-Pads can be treated in two ways depending on the controller and the platform: they can be buttons (each DPad button has a button ID) or axes (one horizontal axis and one vertical axis). On Windows the XBox360 controller D-Pad is treated as a pair of axes (the horizontal and the vertical), so because of that we need to check \"DPad is axis\" and edit DPad horizontal and DPad vertical accordingly. If, for instance, your controller treats the D-Pad as buttons, uncheck \"DPad is axis\" and configure the button IDs in the Buttons section.",
            "title": "The D-Pad"
        },
        {
            "location": "/controller-profiles/#the-axes",
            "text": "Each axis has an ID, an input range, an output range and can be inverted. The ID and inversion of the value is pretty straight forward, but what are these input and output ranges? The input range is the value EzInput will receive from the controller and the output range is what you will get when you call  GetAxis() . For example: in the PS4 controller on PC trigger values range from -1 to 1 (-1 being fully released and 1 being fully pressed) but it seems more logical to have it ranging between 0 and 1, don't you think? So we have to set \"Min input range\" to -1, \"Max input range\" to 1, \"Min output range\" to 0 and \"Max output range\" to 1.",
            "title": "The Axes"
        },
        {
            "location": "/controller-profiles/#creating-a-controller-profile",
            "text": "To create a new controller profile file go to the Project tab in the Editor, right click, Create->EzInput->Controller Profile.",
            "title": "Creating a controller profile"
        },
        {
            "location": "/controller-profiles/#setting-the-name-of-the-controller",
            "text": "The profile stores the name of the controller it is for in the \"Name\" field (it's the first field in the controller profile editor, you'll find it). Be careful when setting the controller name because it has to match exactly the name of the controller. You can find the name of your controller in the  test scene  or you can use  Input.GetJoystickNames()  and look into the string array it returns.",
            "title": "Setting the name of the controller"
        },
        {
            "location": "/controller-profiles/#setting-the-platform-of-the-profile",
            "text": "You can restrict a controller profile to a specific platform by selecting it in the \"Target platform\" field (you can also select multiple target platforms). Now, you'd probably be asking yourself why do this? The reason behind that is simple. Let's take the XBox 360 controller, in Windows the D-pad works as a pair of axes but in OSX the D-pad is treated as group of buttons. So if you had the same profile for Windows and OSX you'd get incorrect input from the same controller.   Note  If the platform you're selecting is WindowsPlayer, OSXPlayer or LinuxPlayer dont forget to check their editor versions (WindowsEditor, OSXEditor, LinuxEditor). If you dont do this your controller profile won't work in the editor (but it will work on a build).   You'll also need to add it to the list in the EzInput prefab located at  EzInput/Resources , if you don't EzInput won't even know it exists.   Warning  Don't forget to add your new Controller Config file to the list in the EzInput prefab in  EzInput/Resources . I know it's written on the line above but you might have skipped that part so here's a big orange warning to catch your attention and save you a headache. You're welcome :)",
            "title": "Setting the platform of the profile"
        },
        {
            "location": "/controller-profiles/#default-controller-profile",
            "text": "When you connect a controller EzInput tries to find a ControllerProfile that matches your controller and platform. If it can't find one it uses the default controller profile. The default controller profile is located at the EzInput prefab in  EzInput/Resources .",
            "title": "Default Controller Profile"
        },
        {
            "location": "/the-test-scene/",
            "text": "The test scene\n\n\nThe test scene is a scene that comes with EzInput that you can use to help in the process of configuring your controller profiles. It has the layout of a PS4 controller (isn't much different from the XBox controller layout, the only thing different is that the Left stick and D-Pad have swapped positions). When you press a button, a trigger or move a stick you will see the changes in the screen. This allows you to track down wrongly set up buttons and axes in your controller and fix them.  \n\n\nYou can select which controller you want to test on the top right corner of the screen, there's a list with all connected controllers there.\n\n\n\n\nNote\n\n\nsometimes the list might not update when connecting/disconnecting a controller so you might need to click \"Refresh list\".\n\n\n\n\nOn the top left corner of the screen you can find a list of all of your keybindings along with their current values.",
            "title": "The test scene"
        },
        {
            "location": "/the-test-scene/#the-test-scene",
            "text": "The test scene is a scene that comes with EzInput that you can use to help in the process of configuring your controller profiles. It has the layout of a PS4 controller (isn't much different from the XBox controller layout, the only thing different is that the Left stick and D-Pad have swapped positions). When you press a button, a trigger or move a stick you will see the changes in the screen. This allows you to track down wrongly set up buttons and axes in your controller and fix them.    You can select which controller you want to test on the top right corner of the screen, there's a list with all connected controllers there.   Note  sometimes the list might not update when connecting/disconnecting a controller so you might need to click \"Refresh list\".   On the top left corner of the screen you can find a list of all of your keybindings along with their current values.",
            "title": "The test scene"
        },
        {
            "location": "/code-reference/",
            "text": "Code reference\n\n\nHere you can find a list of methods to get the input data you desire:\n\n\nbool\n \nGetButton\n(\nButtonCode\n \n_button\n,\n \nInputState\n \n_state\n,\n \nint\n \n_controller\n \n=\n \nALL\n)\n\n\n\n\n\n\nbool\n \nGetButton\n(\nstring\n \n_binding\n,\n \nInputState\n \n_state\n,\n \nint\n \n_controller\n \n=\n \nALL\n)\n\n\n\n\n\n\nfloat\n \nGetAxis\n(\nAxisCode\n \n_axisCode\n,\n \nint\n \n_controller\n \n=\n \nALL\n)\n\n\n\n\n\n\nfloat\n \nGetAxis\n(\nstring\n \n_binding\n,\n \nint\n \n_controller\n \n=\n \nALL\n)\n\n\n\n\n\n\n_controller\n is the index of the controller you want to get the value from. If you want to get the value from all controllers use \nEzInput.ALL\n.  \n\n\n\n\nNote\n\n\nThe \n_controller\n parameter is zero-based e.g. the ID of the third controller is 2).\n\n\n\n\n_binding\n the name of the binding in the Bindings Scriptable Object you wish to get the value from.\n\n\n_button\n the button you want to get the value from.\n\n\n_axis\n the axis you want to get the value from.  \n\n\n\n\nNote\n\n\nGetAxis\n will \nalways\n return a value between -1 and 1. However, this doesn't mean that if the axis can output a negative value. Depending on your Controller Config and the axis you're read it will or won't be able to output negative values. E.g. if configured accordingly a trigger will output 0 when released and a 1 when pressed.\n\n\n\n\n\n\nNote\n\n\nAll these methods are static so you can call \nEzInput.Getbutton\n.\n\n\n\n\n\n\nWarning\n\n\nDon't forget to declare that you're using the \nEzInputManager\n namespace at the top of your .cs file like \nusing EzInputManager\n.",
            "title": "Code reference"
        },
        {
            "location": "/code-reference/#code-reference",
            "text": "Here you can find a list of methods to get the input data you desire:  bool   GetButton ( ButtonCode   _button ,   InputState   _state ,   int   _controller   =   ALL )   bool   GetButton ( string   _binding ,   InputState   _state ,   int   _controller   =   ALL )   float   GetAxis ( AxisCode   _axisCode ,   int   _controller   =   ALL )   float   GetAxis ( string   _binding ,   int   _controller   =   ALL )   _controller  is the index of the controller you want to get the value from. If you want to get the value from all controllers use  EzInput.ALL .     Note  The  _controller  parameter is zero-based e.g. the ID of the third controller is 2).   _binding  the name of the binding in the Bindings Scriptable Object you wish to get the value from.  _button  the button you want to get the value from.  _axis  the axis you want to get the value from.     Note  GetAxis  will  always  return a value between -1 and 1. However, this doesn't mean that if the axis can output a negative value. Depending on your Controller Config and the axis you're read it will or won't be able to output negative values. E.g. if configured accordingly a trigger will output 0 when released and a 1 when pressed.    Note  All these methods are static so you can call  EzInput.Getbutton .    Warning  Don't forget to declare that you're using the  EzInputManager  namespace at the top of your .cs file like  using EzInputManager .",
            "title": "Code reference"
        },
        {
            "location": "/the-ezinput-prefab/",
            "text": "The EzInput prefab\n\n\nWhen the game starts (in the editor or in a build) an EzInput Game Object is created and that's where the logic runs. It's prefab can be found at \nEzInput/Resources\n and there you can change the Bindings file EzInput will use, you can change all Controller Configs (there's an array there) and the default Controller Config.",
            "title": "The EzInput prefab"
        },
        {
            "location": "/the-ezinput-prefab/#the-ezinput-prefab",
            "text": "When the game starts (in the editor or in a build) an EzInput Game Object is created and that's where the logic runs. It's prefab can be found at  EzInput/Resources  and there you can change the Bindings file EzInput will use, you can change all Controller Configs (there's an array there) and the default Controller Config.",
            "title": "The EzInput prefab"
        }
    ]
}